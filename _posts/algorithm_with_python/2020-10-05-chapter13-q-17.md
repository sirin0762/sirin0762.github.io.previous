---
layout: post
title: 'chapter 13 : 실전 bfs/dfs 17번 문제(경쟁적 전염)'
date: 2020-10-05
category: algorithm
---
# 문제 : 경쟁적 전염
[문제링크](https://www.acmicpc.net/problem/18405)
## 내 생각
이 문제는 배열을 순회하면서 바이러스의 순서에 따라 바이러스를 퍼트려야하는 문제이다. 즉, bfs를 한 번씩 상하좌우로만 하며 바이러스를 퍼트려야한다.   
연쇄되는 바이러스 전염을 막기위해 visited라는 2차원 배열을 매초 초기화 하여 쓰며 해당 알고리즘을 풀어나간다.   
1. 입력
2. 시간 초 설정(반복문)
3. 바이러스 순서(반복문)
4. visited 초기화
5. 바이러스 전염 시작(반복문)
6. 다시 바이러스 전염을 위한 visited 초기화   

이 순서로 하면 될 것 같다.

## 내 코드
```python
# 경쟁적 전염
# 매 초 번호가 낮은 바이러스부터 퍼짐
# 1초당 상하좌우 1칸씩

# 1. 입력
# 2. 시간 초 설정(반복문)
# 3. 바이러스 순서(반복문)
# 4. visited 초기화
# 5. 바이러스 전염 시작(반복문)
# 6. 다시 바이러스 전염을 위한 visited 초기화  

#4
def infection(x, y):
  dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]
  visited[x][y] = True
  for i in range(4):
    nx, ny = x + dx[i], y + dy[i]

    if nx >= n or ny >= n or nx < 0 or ny < 0:
      continue

    if plask[nx][ny] == 0:
      plask[nx][ny] = plask[x][y]
      visited[nx][ny] = True

# 1. 입력
n, k = map(int, input().split())

# 시험관의 정보
plask = []

for _ in range(n):
  plask.append(list(map(int, input().split())))

visited = [[False] * n for _ in range(n)]
s, x, y = map(int, input().split())

# 2. 시간 초 설정
count = 0

while count < s:
  # 3. 바이러스 설정
  for virus in range(1, k + 1):
    # 4, 6 : visited 초기화
    visited = [[False] * n for _ in range(n)]
    # 5 : 바이러스 전염
    for i in range(n):
      for j in range(n):
        if plask[i][j] == virus and visited[i][j] == False:
          infection(i, j)

  count += 1

print(plask[x - 1][y - 1])

```
