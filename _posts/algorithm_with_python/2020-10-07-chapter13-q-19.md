---
layout: post
title: "chpater 13 : 실전 bfs/dfs 19번 문제(연산자 끼워넣기)"
date : 2020-10-07
category: algorithm
---
# 문제 : 연산자 끼워넣기
[문제 링크](https://www.acmicpc.net/problem/14888)
## 내 생각
이 문제는 완전 탐색을 통해서 문제를 풀어야한다고 생각했다. 연산자의 개수를 순열을 통해서 이리저리 바꾸면서 앞에서 부터 연산하여 그 값을 리스트에 저장, 모든 작업이 끝나면 가장 큰 값과 가장 작은 값을 출력하면 된다고 생각했다.   
내 아이디어는 이렇다.   
1. 입력을 받는다.
2. 사칙연산을 순열을 통해 모든 경우의 수를 고려하게 만든다.
3. 앞에서부터 사칙연산을 한다.
4. 사칙연산을 한 결과를 리스트에 저장한다.
5. 리스트에서 가장 큰 값과 가장 작은 값을 출력한다.

## 내 코드
```python
# 연산자 끼워 넣기
# 주어진 수와 연산자로 최대, 최솟값을 구하시오
# 연산은 무조건 앞에서 뒤로 이루어진다.
# 나눗셈은 몫만 취한다
# 음수를 양수로 나누면 양수로 바꿔 몫을 취한뒤 음수로 바꾼다.

# 알고리즘
# 1. 입력
# 2. 사칙연산 조합 생성
# 3. 사칙연산 조합으로 앞에서 부터 산수
# 4. 산수 나온 결과를 리스트에 대입, max, min으로 결과 도출

from itertools import permutations

def conduct_calculation(answer,operand, operate):
  if operate == '+':
    return answer + operand
  elif operate == '-':
    return answer - operand
  elif operate == '*':
    return answer * operand
  elif operate == '/':
    if answer < 0:
      return -(abs(answer) // operand)
    else:
      return answer // operand

# 1. 
n = int(input())
numbers = list(map(int, input().split()))
operates = ''
k = list(map(int, input().split())) # k = 사칙연산의 개수

# 2. 
operates += '+' * int(k[0])
operates += '-' * int(k[1])
operates += '*' * int(k[2])
operates += '/' * int(k[3])

operates = list(operates)
operates_lists = permutations(operates, n - 1)

result = []

for operates_list in operates_lists:
  answer = numbers[0]
  for idx, operate in enumerate(operates_list):
    # 3.
    answer = conduct_calculation(answer, numbers[idx + 1], operate)

  result.append(answer)

# 4.
print(max(result), min(result))
```
