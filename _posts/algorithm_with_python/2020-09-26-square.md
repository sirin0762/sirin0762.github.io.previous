---
layout: post
title:  "programmers level 2 : 가장 큰 정사각형"
date:   2020-09-26 00:53:29 +0900
categories: algorithm
---
# 문제 : 가장 큰 정사각형
0 과 1로 이루어진 N x N 의 정사각형 2차원 배열을 줬을 때 1로 이루어진 가장 큰 정사각형의 크기를 구하시오

# 내 생각
오 2차원 배열? 오 0과 1? 넓이 구하기? 이건 bfs 지! 하고 생각 했다가 바로 당해버렸다... n의 범위가 1000 까지므로 1000 x 1000 이면 기본적으로 1,000,000의 연산을 해야하는데 이걸 생각 못한 것이다. 연산량이 거대하고 문제에서 수학의 향기가 나기 때문에 이 문제는 DP 로 풀어야 한다. 나의 경우, 우선 bfs로 1인 x, y 값을 리스트에 담아서 이를 이용하여 정사각형을 확인하려 했지만 정사각형을 구하는 알고리즘을 생각하지 못하여 풀지 못했다. 

# 해결법
위에서 언급한 것처럼, DP를 통해서 해야한다. 정사각형의 한 포인트(배원의 원소)를 기준으로 좌, 상단, 좌측 상단을 확인하여 해당 원소에 다시 값을 할당해야한다. 예를 들면, (2,2) 에서 확인 하면 (1,2), (2,1), (1,1) 의 원소들의 값을 보고, 그 값중에 최솟값의 값의 + 1을 (2,2)에 할당하면 된다. 단, 원래의 (2,2) 의 값은 0 이상이여야 한다.

# 코드
```python
def solution(board):
    # 정사각형의 한 변의 길이
    row = len(board)
    col = len(board[0])
    max_point = 0
    sum_point = 0
    # 모든 배열이 0 인경우
    for i in range(row):
        sum_point += sum(board[i])
    
    if sum_point == 0:
        return 0
    
    # 배열 내부로 진입
    for i in range(1, row):
        for j in range(1, col):
            
            # 우측 아래가 0이 아니라면
            if board[i][j]:
                # 정사각형 변의 길이 구하기 : 우측아래가 0이 아니고 나머지 3개의 최솟값에 + 1
                board[i][j] = min(board[i][j - 1], board[i - 1][j], board[i - 1][j - 1]) + 1
                max_point = max(board[i][j], max_point)   
    if max_point:
        return max_point ** 2
    # max_point = 0 일 떄는 1을 리턴(가장 작은 정사각형 크기)
    else:
        return 1
```
# 느낀점
일단 문제를 잘 읽어보지 않고 섣부르게 bfs로 접근하려고 하여 시작부터 꼬인 문제이다. 물론 bfs로도 풀수 있는 문제이지만, DP가 효율성 면에서 훨씬 더 좋다고 생각한다. 요즘들어 특히 더 느끼지만, 읽는 것을 잘하는 것이 문제에 해결하는데에 가장 기초가 되는 것 같다. 서투르게 문제를 풀려하지말고 천천히 읽어나가는 연습부터, 좀 오래걸리더라도 꾸준히 해야겠다.
